what is Django:
CGI: common gate way intefrace..

[pip install django]

    this is an open source web development framework,,hwich is mainy used to framework..

# some of the admin classes/function  of django:django-admin

check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    dumpdata
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    optimizemigration
    runserver
    sendtestemail
    shell
    showmigrations
    sqlflush
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    test
    testserver


# to start the project we use
<!-- django-admin startproject django_project -->

# to change the directory we use:
<!-- cd filename -->

# change directory to project/filename:
<!-- cd django_project/ -->

# after this got the file and view there will be a project present in file..

<!-- add that entire file to code editor.. -->
<!-- and in that we have settings/init/url/wsgi/manage files.. -->

# Some of the files we find once the directory is found.

<!-- init: this is the file where it shouws it is pyhton file project..

settings : this is the file that where our security and some predefined application given by django is stored..

url: this is the section where our all page urs will be stored..[admin/], where we can use the admin section using "www.our.application.admin/"

wsgi: this is the file which is used to connect the python and the web appilication.. -->


# once after this we need to run:

<!-- python manage.py runserver -->
# which gives us the localhost server 127:0:0:1:8000 port

where we can acces this link and check..
we can change the link to

<!-- 127:0:0:1:8000 -->

we can check for admin block as we have in url-file,

<!-- localhost:8000/admin -->

# to set any new url of the page we can use url_py;

eg:

<!-- urlpatterns=[
    path('dashboard/', dashboard.site.urls),
] -->


after the use we can close our local host we can use:

<!-- CTRL C: to stop the server. -->

# to start the  django app we use command:

 <!-- python manage.py startapp blog -->  [we can check these command are available in help command]
        [BLOG is the file name u want to create..]

# once the file blog is created now we start building our application home page function
[ i am writing function to handle the traffic of the home page when user logins.. ]

for that we need to take responces from user, so we need to request for the user.

we need to import:
<!-- from django.http import HttpResponce --> this import will collect the respoce from the users..

# Creating the function home(request) which is used sen dthe request and collect the responce..

<!-- def home(request):
        return HttpResponse("<h1> hi this is home page </h1>") -->

Here we are handling the user when he comes to home page.

To redirect user we are creating a "urls.py" file, where we  map the function for each view/page user view.

# This "blog/urls.py" file will be same as "urls.py" in django_project.

# Create a file called "urls.py" under blog and add the path to Home page.

# to add the path we need to import files from "views.py" and "path" as well
<!-- from . import views
from django.urls import path -->

# we create a constructer as same as in "urls.py" in django_project.
<!-- 
urlpatterns = [
    path('',views.home, name='blog-home')
] --> 
# here '' is the extension path for the home page. and we are calling the home function from here.

# Then we need to connect "blog/urls.py" file into  "urls.py" in django_project.
<!-- we need to include import it comes with path as well.
    in urlpatterns constructer we can add another path. -->

<!--path('blog/', include('blog/urls)), -->

# once after this run the server and check.

# further if we need to add  more function's ex: about, we can just keep on adding in "blog/urls.py" and in the functions in "views.py" file.

in views:
<!-- def about(request):
        return HttpResponse("<h1> hi this is about page </h1>") -->

in urls.py:
    path('about/', views.py,name='about-page'),

# if we run trhe server we get both the page.[localhost:8000/blog/about] //for about page and [localhost:8000/blog/] //for home page.


<!-- ################################################################################ -->
# end of basics:
from line 200 advance:



















































# we cant keep creating functions for all so we are adding a single page to every single templates and the using the templates we are accesing each and every file.

# Create a folder under blog names "templates" and under templates create another folder "blog"
blog -> temaplates -> blog 

# create a file for each of the functions under blog folder.
blog -> temaplates -> blog ---// home.html


# once this is created go to "views.py" file 
# previosly we used to use HttpResponce for the accessing of the file, we can sue another function as we are rendering the file from another folder.. we use 
<!-- from django.shortcuts import render -->

# In ther created function home, change the return statement as 

<!-- return render(request,'blog/home.html') -->
        <!-- return HttpResponse("<h1> hi this is home page </h1>") -->
        <!-- return render(request, 'path of the file located')-->


# Lets try to access some dummy created by cerating a dummy data form the dictonary//
# we are passing the dummy data inside the list/dictornary so that using key:value we can access the data easily..

    ex: posts=[
       {
        'author': 'amith',
        'title': 'blog1',
        'dateposted': 'january'
    },
    {
        'hi':'hello',
        'wfh':'yes'
    }
    ]

# to access this data we need to create a list and an obj which is easier to access the above dummy data.

inside the function
ex: def home(request):
        context={
           #obj 'storealldata'=posts # dummy data list name.[all the data will be stored in the object]
        }
        return render(request, 'file path name', context)[render function accepts only 3 parameters so we are passing the context through ehich we can access the data.]

# the another thing in here we need to access the data in html file.// for that we use 
<!-- <body>
            {% for post in storealldata %}   # storealldata is the variable dictonary where we have stored our data
                <h1> {{post.author}}</h1>
                <p> {{post.title}}</p>
                <p>on {{post.dateposted}}</p>
            {% endfor %}  # ending of this very important
        </body> -->

# This is the another method, as we are writing the same lines of code several times we can make a static file where we can store a similary code and change once for all, when we needed.
# that is done by cerating an another file called "base.html" under "blog" 
        <!-- "templates->blog->base.html" -->

# once the file is created we add the repeated code to that file, and logic og each page in a "{block}"
for ex:
<!-- <!DOCTYPE html>
<html>
    <head>

        {% if title %}
            <title> learning {{title}}</title>
        {% else %}
            <title> started learning</title>
        {% endif %}

        <body>
            {% block content%} {% endblock content%}
        </body>

    </head>
</html> -->

# As in the home.html and the about.html there is an logic difference between the body so we are making it as block and all the other things as static.

# now in home page
# * first we need to extend the base.html file to home.html, so for that we use 
<!-- {% extends 'blog/base.html'%} -->
# * and next create a block where the logic has to be. {block}

for home page
<!-- {% extends 'blog/base.html'%} -->
<!-- {% block content%}
        {% for post in store %}
            <h1> {{post.author}}</h1>
            <p> {{post.title}}</p>
            <p>on {{post.dateposted}}</p>
        {% endfor %} 
      {% enbdblock content %}  -->

for about page
<!-- {% extends 'blog/base.html'%}
{% block content %} 
    <h1> this is about page </h1>
{% endblock content %} -->

# THE BIG USE OF THIS IS, WE NO NEED TO WRITE ALL THE THINGS JUST WE NEED TO MAKE CHNAGES IN BLOG WHERE IT WILL CHANGE IN ALL THE PAGES.

# To make our project little intresting  added some "html nav bar code" inside body and "main html" as well,  and  AS WE NEED CSS WHICH IS STATIC SO  CREATE A FOLDER CALLED :STATIC: INSIDE STATIC CREATE ANOTHER FOLDER CALLED :BLOG: AS IT IS OUR APP NAME, INSIDE THAT CREATE A MAIN.CSS FILE 

"BLOG -> STATIC -> BLOG -> .CSS FILE"

# after that run the server again so that css gets load..

# In main file that is "basic.html" we have given .about, /blog[which is not correct if anything chnages we need to chnage in all place]  so change the path to [url 'name of the file given in "views.html"] 
ex:

<!--   <a class = "navbar-item nav-link" href="{% url 'blog-home'%}">Home</a>
        <a class = "navbar-item nav-link" href="{% url 'blog-about' %}">About</a> 
-->

<!-- ################################################################################### -->
# continue from line 330
# creating a :admin-user: "Super User"













# We are creating the admin user for the admin acces which is Super User
<!-- To Create Super User we have a command "createsuperuser" -->
<!-- python manage.py createsuperuser -->
# Run the command by stopping the server

* Error[ an error will be generated beacuse of teh below reason.] 

    <!-- django.db.utils.OperationalError: no such table: auth_user -->

    # why error??
    # Since we havn't created a database that we user for this project!!

# creating a database is simple here, just we need to run few "Migration" command.

# ":migration": is basicly used to apply the changes to database.

Once we use migration as we haven't created databsed it adds some tables to the database , and then it allows "createsuperuser"

<!-- python manage.py makemigrations -->

# after running the command o/p will be "No Changed Detected" [as the migration is  creating database] !!! [if user have created database user will get changed displayed.!! ]


# To apply the changes in migrations need to run this command:
 <!--python manage.py migrate  -->
# [which helps the migrations to update]

# once after running above command now you can create your super-user:

<!-- python manage.py createsuperuser
Username (leave blank to use 'chiku'): amith
Email address: amithtalentplace@gmail.com
Password: New@1234
Password (again): New@1234
Superuser created successfully. -->


# After this run the server again

# [ U will be able to watch the admin blof try login , once you enter click on users and username which u created!!]

U will get to see the Password: with some [#labels] which is the added more security in Django.

<!-- ex:
password: algorithm: pbkdf2_sha256 iterations: 600000 salt: MSw5ES**************** hash: Sp5B1i************************************** -->

[we can add users there /delete users / can provide the permission there itself.]



# Creting own Database:
 # [To work with the data base, jango has the excellent advantage which is "ORM" in it..]

 ORM: "OBJECT RELATIONAL MAPPER": 
# We can access database easily using the objects, and we can access other database as well without changing the code.

# Using SQLlite for the devlopment and Postgres database for the production..

# any changed in the database or updation , will be done in "blog/model.py" file..


# In "models.py" where we wanna think what need to store in our database.[ can  create a user from here as well and add some more fields than in amdin page for the users]
# [to do all these we need a databse model, which is already created by the Django, can     inherit the models class.]
# [Can create our owm model as well.]]


# now we are creating a class/ which is Table called :Post: in which we are giving the column names we need.

class Post(models.Model):                     <!--[models.Model]-> using this we create a table in the database [for models we need to "import from django.db import models"] -->
    title=models.Charfeild(max_length=100)                   -> <!-- there are the attributes that we are adding to the table Post..-->
     author=models.TextFeild()                                -> <!--Charfeild and TextFeild are same but text feild doesnt has any limit.. -->
    date_posted = models.DateTimeField(default=timezone.now) -> <!-- For the date attribute provide date format, for "default" we need to "import timezone from django.utils" -->
    author = models.Foreignkey(User, on_delete=models.CASCADE) -> <!-- author name we are taking form the "User" database table, so making it as ForignKey, and on_delete, means if the author gets delete in "User" table then just delete the name of the author from the Post table , dont delete the data form database. -->

ex:
class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    date_posted = models.DateTimeField(default=timezone.now)
    author = models.ForeignKey(User, on_delete=models.CASCADE)

# after creating the file adding/creating the above database table

# We need to add it to the database , so for that we need to run the migrations

<!-- python manage.py makemigrations --> [which means make the changes in database.]

# after running this the Django, creates it folder as "migrations" under blog.
<!-- Migrations for 'blog':
  blog/migrations/0001_initial.py  
    - Create model Post -->
    blog -> migrations -> 00001_initial.py

# to get the sql query for t5he above table need ti run the command.

<!-- python manage.py sqlmigrate blog 0001 -->[blog 0001]-> is the app name and file name

BEGIN;
--
-- Create model Post
--
CREATE TABLE "blog_post" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(100) NOT NULL, "content" text NOT NULL, "date_posted" datetime NOT NULL, "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE INDEX "blog_post_author_id_dd7a8485" ON "blog_post" ("author_id");
COMMIT;

<!--  Then save it to database using python manage.py migrate -->

# To access the data we need to run in "python shell"
so, 
<!-- python manage,py shell -->

# now we need to import the files to shell soo,

<!-- from blog.models import Post 
     from django.contrib.auth.models import User -->

<!-- To print the data from User or Post we use, "Tablename.objects.all()"-->
ex:
<!-- User.objects.all()
    Post.objects.all() -->

# We can use the filter as well to get the data

ex:
<!-- User.objects.all()  -> which return all the record -->
<QuerySet [<User: amith>, <User: Sudeshdas>]>
<!-- User.objects.first() -> which gives the first record -->
<User: amith>
<!-- User.objects.last()  -> which gives the last user from the table. -->
<User: Sudeshdas>

<!-- User.objects.filter(username='amith') -> Gets the name with amith from the db  -->
<User: amith>
<!-- User.objects.filter(username = 'amith').first()  gets the name with amith with the first matching record from the db..-->
<User: amith>

# by using variable as well we can store and gets the data:
<!-- user = User.objects.filter(username = 'amith').first() -->
<!-- user -->

# As the migration file we saw, the id has been created for every user incrementally, we can access the user using ID as well.

<!-- user.id --> [as in user amith is stired where his id :1]
1

<!-- user.pk --> [we can get the id using primary key as well]
1

<!-- user = User.objects.get(id=1)  -> using this filter as well can fetch the data. -->
<!-- user -->
<User: amith>

# Without adding any data when we try to access we get like
<!-- Post.objects.all() -->
<QuerySet []>

 # To add the data
<!-- post_1 = Post(title='django',author= user,content='learning django it is awesome') 
        -> as already in user variable we have the 'amith' so in field of author we used "user", and as default function gives the date base don current date, so no nned to add that attribute..-->

# save the data
<!-- post_1.save() -->

# when we try to view the data 
<!-- Post.objects.all() -->
<QuerySet [<Post: Post object (1)>]>


# As we have only addedd attributes in "Post" function there is no return statement so we get like the above thing..

# exit from the shell 
<!-- exit() -->

# Need to create a dunder STR method in "models.py file" [any data we need to print on shell]

<!-- def __str__(self):
        return self.title -->


#  to get the updated files, re-open all the "import files" then access.

<!-- pyhton manage.py shell -->

 <!--  from blogs.models import Post 
       from django.contib.auth.models import User-->

<!-- Post.objects.all() -->
<QuerySet [<Post: Django>]>

<!-- user1 = User.objects.filter(username='sudeshdas').firstname()
user1 -->
<User: Sudeshdas>

<!-- post_2 = Post(title='ReactJs', author='user1',content='good in react') -->
<!-- post_2.save() -->
# we can sue user1.id as well for author name!
<!-- post_2 = Post(title='ReactJs', author='user1.id',content='good in react') -->
<!-- post_2.save() -->

<!-- Post.objects.all() -->
<QuerySet [<Post: Django>, <Post: ReactJs>]>

<!-- post = Post.objects.first() -> stroing all the details of the first user in post variable, so that we can accces all theb data using the variable itself.  -->

<!-- post.content -->
'learning django it is awesome'

<!-- post.id -->
1

<!-- post.author -->
<User: amith>

<!-- post.email  -> here as we are not storing the email in "Post" class but still we are able to get the all data of teh user[because of the foreign key.] -->
'amithtalentplace@gmail.com'

<!-- post.date_posted  -->
datetime.datetime(2023, 8, 8, 8, 41, 18, 611145, tzinfo=datetime.timezone.utc)


# to get all the posts posted by the user we can view like.
[Syntax: modelname/variablename.post_set.all()]

<!-- user.post_set.all() -> to get all the posts for the user-->
<QuerySet [<Post: Django>]>

<!-- user1.post_set.all() -> to get all the posts for the user1-->
<QuerySet [<Post: ReactJs>]>




